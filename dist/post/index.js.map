{"version":3,"file":"index.js","mappings":";;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACzJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AClDA;;;;;;;;AAAA;;;;;;;;AAAA;;;;;;;;AAAA;;;;;;;;AAAA;;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC7BA;AACA;;;;;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":[".././config.js",".././util.js","../../../../opt/homebrew/Cellar/ncc/0.38.1/libexec/lib/node_modules/@vercel/ncc/dist/ncc/@@notfound.js","../external node-commonjs \"fs\"","../external node-commonjs \"node:process\"","../external node-commonjs \"os\"","../external node-commonjs \"path\"","../webpack/bootstrap","../webpack/runtime/compat",".././post.js"],"sourcesContent":["const fs = require('fs')\nconst os = require('os')\nconst yaml = require('yaml')\nconst core = require('@actions/core')\nconst github = require('@actions/github')\n\nconst bazeliskVersion = core.getInput('bazelisk-version')\nconst cacheVersion = core.getInput('cache-version')\nconst externalCacheConfig = yaml.parse(core.getInput('external-cache'))\n\nconst homeDir = os.homedir()\nconst arch = os.arch()\nconst platform = os.platform()\n\nlet bazelDisk = core.toPosixPath(`${homeDir}/.cache/bazel-disk`)\nlet bazelRepository = core.toPosixPath(`${homeDir}/.cache/bazel-repo`)\nlet bazelOutputBase = `${homeDir}/.bazel`\nlet bazelrcPaths = [core.toPosixPath(`${homeDir}/.bazelrc`)]\nlet userCacheDir = `${homeDir}/.cache`\n\nswitch (platform) {\n  case 'darwin':\n    userCacheDir = `${homeDir}/Library/Caches`\n    break\n  case 'win32':\n    bazelDisk = 'D:/_bazel-disk'\n    bazelRepository = 'D:/_bazel-repo'\n    bazelOutputBase = 'D:/_bazel'\n    userCacheDir = `${homeDir}/AppData/Local`\n    if (process.env.HOME) {\n      bazelrcPaths.push(core.toPosixPath(`${process.env.HOME}/.bazelrc`))\n    }\n    break\n}\n\nconst baseCacheKey = `setup-bazel-${cacheVersion}-${platform}`\nconst bazelrc = core.getMultilineInput('bazelrc')\n\nconst diskCacheConfig = core.getInput('disk-cache')\nconst diskCacheEnabled = diskCacheConfig !== 'false'\nlet diskCacheName = 'disk'\nif (diskCacheEnabled) {\n  bazelrc.push(`build --disk_cache=${bazelDisk}`)\n  if (diskCacheName !== 'true') {\n    diskCacheName = `${diskCacheName}-${diskCacheConfig}`\n  }\n}\n\nconst repositoryCacheConfig = core.getInput('repository-cache')\nconst repositoryCacheEnabled = repositoryCacheConfig !== 'false'\nlet repositoryCacheFiles = [\n  'MODULE.bazel',\n  'WORKSPACE.bazel',\n  'WORKSPACE.bzlmod',\n  'WORKSPACE'\n]\nif (repositoryCacheEnabled) {\n  bazelrc.push(`build --repository_cache=${bazelRepository}`)\n  if (repositoryCacheConfig !== 'true') {\n    repositoryCacheFiles = Array(repositoryCacheConfig).flat()\n  }\n}\n\nconst googleCredentials = core.getInput('google-credentials')\nconst googleCredentialsSaved = (core.getState('google-credentials-path').length > 0)\nif (googleCredentials.length > 0 && !googleCredentialsSaved) {\n  const tmpDir = core.toPosixPath(fs.mkdtempSync(os.tmpdir()))\n  const googleCredentialsPath = `${tmpDir}/key.json`\n  fs.writeFileSync(googleCredentialsPath, googleCredentials)\n  bazelrc.push(`build --google_credentials=${googleCredentialsPath}`)\n  core.saveState('google-credentials-path', googleCredentialsPath)\n}\n\nconst bazelExternal = core.toPosixPath(`${bazelOutputBase}/external`)\nconst externalCache = {}\nif (externalCacheConfig) {\n  const { workflow, job } = github.context\n  const manifestName = externalCacheConfig.name ||\n    `${workflow.toLowerCase().replaceAll(/[ /]/g, '-')}-${job}`\n\n  externalCache.enabled = true\n  externalCache.minSize = 10 // MB\n  externalCache.baseCacheKey = `${baseCacheKey}-external-`\n  externalCache.manifest = {\n    files: [\n      'MODULE.bazel',\n      'WORKSPACE.bazel',\n      'WORKSPACE.bzlmod',\n      'WORKSPACE'\n    ],\n    name: `external-${manifestName}-manifest`,\n    path: `${os.tmpdir()}/external-cache-manifest.txt`\n  }\n  externalCache.default = {\n    enabled: true,\n    files: [\n      'MODULE.bazel',\n      'WORKSPACE.bazel',\n      'WORKSPACE.bzlmod',\n      'WORKSPACE'\n    ],\n    name: (name) => { return `external-${name}` },\n    paths: (name) => {\n      return [\n        `${bazelExternal}/@${name}.marker`,\n        `${bazelExternal}/${name}`\n      ]\n    }\n  }\n\n  for (const name in externalCacheConfig.manifest) {\n    externalCache[name] = {\n      enabled: externalCacheConfig.manifest[name] != false,\n      files: Array(externalCacheConfig.manifest[name]).flat()\n    }\n  }\n}\n\nmodule.exports = {\n  baseCacheKey,\n  bazeliskCache: {\n    enabled: core.getBooleanInput('bazelisk-cache'),\n    files: ['.bazelversion'],\n    name: 'bazelisk',\n    paths: [core.toPosixPath(`${userCacheDir}/bazelisk`)]\n  },\n  bazeliskVersion,\n  bazelrc,\n  diskCache: {\n    enabled: diskCacheEnabled,\n    files: [\n      '**/BUILD.bazel',\n      '**/BUILD'\n    ],\n    name: diskCacheName,\n    paths: [bazelDisk]\n  },\n  externalCache,\n  paths: {\n    bazelExternal,\n    bazelOutputBase: core.toPosixPath(bazelOutputBase),\n    bazelrc: bazelrcPaths\n  },\n  os: {\n    arch,\n    platform,\n  },\n  repositoryCache: {\n    enabled: repositoryCacheEnabled,\n    files: repositoryCacheFiles,\n    name: 'repository',\n    paths: [bazelRepository]\n  },\n}\n","// https://www.npmjs.com/package/get-folder-size\n// Adapted for CommonJS and synchronous Filesystem calls.\n\nconst fs = require('fs')\nconst path = require('path')\n\nasync function getFolderSize (rootItemPath, options = {}) {\n  const fileSizes = new Map()\n\n  await processItem(rootItemPath)\n\n  async function processItem (itemPath) {\n    if (options.ignore?.test(itemPath)) return\n\n    const stats = lstatSync(itemPath, { bigint: true })\n    if (typeof stats !== 'object') return\n\n    fileSizes.set(stats.ino, stats.size)\n\n    if (stats.isDirectory()) {\n      const directoryItems = fs.readdirSync(itemPath)\n      if (typeof directoryItems !== 'object') return\n      await Promise.all(\n        directoryItems.map(directoryItem =>\n          processItem(path.join(itemPath, directoryItem))\n        )\n      )\n    }\n  }\n\n  let folderSize = Array.from(fileSizes.values()).reduce((total, fileSize) => total + fileSize, 0n)\n\n  if (!options.bigint) {\n    if (folderSize > BigInt(Number.MAX_SAFE_INTEGER)) {\n      throw new RangeError('The folder size is too large to return as a Number. You can instruct this package to return a BigInt instead.')\n    }\n    folderSize = Number(folderSize)\n  }\n\n  return folderSize\n}\n\nfunction lstatSync(path, opts) {\n  try {\n    return fs.lstatSync(path, opts)\n  } catch (error) {\n    return\n  }\n}\n\nmodule.exports = { getFolderSize }\n",null,"module.exports = require(\"fs\");","module.exports = require(\"node:process\");","module.exports = require(\"os\");","module.exports = require(\"path\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\tvar threw = true;\n\ttry {\n\t\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\t\tthrew = false;\n\t} finally {\n\t\tif(threw) delete __webpack_module_cache__[moduleId];\n\t}\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","\nif (typeof __webpack_require__ !== 'undefined') __webpack_require__.ab = __dirname + \"/\";","const fs = require('fs')\nconst path = require('path')\nconst cache = require('@actions/cache')\nconst core = require('@actions/core')\nconst glob = require('@actions/glob')\nconst config = require('./config')\nconst { getFolderSize } = require('./util')\nconst process = require('node:process');\n\nasync function run() {\n  await saveCaches()\n  process.exit(0)\n}\n\nasync function saveCaches() {\n  await saveCache(config.bazeliskCache)\n  await saveCache(config.diskCache)\n  await saveCache(config.repositoryCache)\n  await saveExternalCaches(config.externalCache)\n}\n\nasync function saveExternalCaches(cacheConfig) {\n  if (!cacheConfig.enabled) {\n    return\n  }\n\n  const globber = await glob.create(\n    `${config.paths.bazelExternal}/*`,\n    { implicitDescendants: false }\n  )\n  const externalPaths = await globber.glob()\n  const savedCaches = []\n\n  for (const externalPath of externalPaths) {\n    const size = await getFolderSize(externalPath)\n    const sizeMB = (size / 1024 / 1024).toFixed(2)\n    core.debug(`${externalPath} size is ${sizeMB}MB`)\n\n    if (sizeMB >= cacheConfig.minSize) {\n      const name = path.basename(externalPath)\n      await saveCache({\n        enabled: cacheConfig[name]?.enabled ?? cacheConfig.default.enabled,\n        files: cacheConfig[name]?.files || cacheConfig.default.files,\n        name: cacheConfig.default.name(name),\n        paths: cacheConfig.default.paths(name)\n      })\n      savedCaches.push(name)\n    }\n  }\n\n  if (savedCaches.length > 0) {\n    const path = cacheConfig.manifest.path\n    fs.writeFileSync(path, savedCaches.join('\\n'))\n    await saveCache({\n      enabled: true,\n      files: cacheConfig.manifest.files,\n      name: cacheConfig.manifest.name,\n      paths: [path]\n    })\n  }\n}\n\nasync function saveCache(cacheConfig) {\n  if (!cacheConfig.enabled) {\n    return\n  }\n\n  const cacheHit = core.getState(`${cacheConfig.name}-cache-hit`)\n  core.debug(`${cacheConfig.name}-cache-hit is ${cacheHit}`)\n  if (cacheHit === 'true') {\n    return\n  }\n\n  try {\n    core.startGroup(`Save cache for ${cacheConfig.name}`)\n    const paths = cacheConfig.paths\n    const hash = await glob.hashFiles(\n      cacheConfig.files.join('\\n'),\n      undefined,\n      // We don't want to follow symlinks as it's extremely slow on macOS.\n      { followSymbolicLinks: false }\n    )\n    const key = `${config.baseCacheKey}-${cacheConfig.name}-${hash}`\n    core.debug(`Attempting to save ${paths} cache to ${key}`)\n    await cache.saveCache(paths, key)\n    core.info('Successfully saved cache')\n  } catch (error) {\n    core.warning(error.stack)\n  } finally {\n    core.endGroup()\n  }\n}\n\nrun()\n"],"names":[],"sourceRoot":""}